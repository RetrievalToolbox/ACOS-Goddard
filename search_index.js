var documenterSearchIndex = {"docs":
[{"location":"known_issues/#Known-Issues","page":"Known Issues","title":"Known Issues","text":"This page lists the currently known issues with this ACOS implementation - these are items that could be changed or fixed in the future. Users should be aware of them when making comparisons to results from ACOS retrievals.","category":"section"},{"location":"known_issues/#Memory-use-due-to-Low-Streams-Interpolation-(LSI)","page":"Known Issues","title":"Memory use due to Low-Streams Interpolation (LSI)","text":"The current version uses a large amount of memory when the retrieval is run with low-streams interpolation to include high-accuracy multiple scattering, including polarization. Peak memory usage is ~7GB when one process is used. This is a result of how the additional instances of the radiative transfer objects are spawned.\n\nThe ACOS algorithm as used with OCO-2/3 measurements requires a total of 4 different RT solver modes: a vector single-scattering one, a scalar two-stream one, a vector two orders of scattering (2OS) one, and a scalar discrete ordinate one for an arbitrary number of streams. During the \"binned\" calculations in which we perform the RT for representative profiles, these four solver modes have to be spawned for every bin. This produces significant overhead in terms of memory. For now, we have chosen to keep the current solution as to not sacrifice legibility for a lower memory footprint. Future versions of RetrievalToolbox or ACOS-Goddard might change this.\n\nFor benchmarking purposes, the memory footprint can be lowered by omitting LSI (--LSI false), disabling polarization (--polarized false) or disabling aerosols (--aerosols false or --retrieve_aerosols false).","category":"section"},{"location":"known_issues/#Non-linearity-and-divergent-steps","page":"Known Issues","title":"Non-linearity and divergent steps","text":"At the moment we find that the retrieval behaves more non-linearly when the modeled and measured radiances are very close to each other. So when getting closer to convergence, the retrieval is more likely to produce a divergent step - meaning that the linear prediction for a given state vector update is wrong and the cost function actually increases as a result of that update. We suspect that some of the Jacobian calculations have small errors in them that become more apparent once the retrieval closes in on a state vector that is close to being converged. As a temporary fix, we add a little code snippet that bumps up the Levenberg-Marquard γ parameter when the retrieval gets closer to convergence:\n\n    chi2 = RE.calculate_chi2(solver)\n    all_chi2_small = true\n    for (k,v) in chi2\n        @info \"$(k): χ² = $(v)\"\n        if (v > 20)\n            all_chi2_small = false\n        end\n    end\n\n    # Manually push gamma to 1000 when we get closer to the solution for better\n    # convergence\n    if (all_chi2_small)\n        solver.gamma = 1000\n        @info \"Setting LM-γ to $(solver.gamma)\"\n    end\n\nSo whenever the retrieval gets to a point where the χ^2 is less than some value (here 20), the γ parameter is bumped up to 1000 to make the state vector update steps smaller, which hopefully keeps the updates in the more linear regime.","category":"section"},{"location":"known_issues/#FootprintGeometry-not-used","page":"Known Issues","title":"FootprintGeometry not used","text":"","category":"section"},{"location":"known_issues/#No-consideration-for-off-pointing-between-spectrometers","page":"Known Issues","title":"No consideration for off-pointing between spectrometers","text":"Both OCO-2 and OCO-3 instruments have slight off-pointing between the three spectrometers, meaning that the locations on Earth that each band \"sees\" is slightly different. While of not much concern regarding smooth geo-physical variables like CO_2 concentrations or aerosol abundance, there could be significant impact due to the varying surface pressure (or total oxygen column) in rough terrain. We do not account for this off-pointing between spectrometers yet.","category":"section"},{"location":"known_issues/#Surface-pressure-Jacobian","page":"Known Issues","title":"Surface pressure Jacobian","text":"","category":"section"},{"location":"known_issues/#BRDF-parameters","page":"Known Issues","title":"BRDF parameters","text":"","category":"section"},{"location":"known_issues/#No-spectral-dependence-of-scattering-phase-function","page":"Known Issues","title":"No spectral dependence of scattering phase function","text":"At the moment, the computation of the scattering phase function expansion coefficients is only done once per spectral window. This means that the overall scattering properties are calculated only once and then re-used for the entire spectral window. At the moment, this is done for performance reasons - the way the coefficients are calculated inside the spectral loop (inside of RT_XRTM.jl) is not optimal and performing the calculation for every spectral point would increase the run-time of retrievals significantly. This will be re-visited. Note, however, that this is an issue related to RetrievalToolbox, rather than our ACOS implementation.","category":"section"},{"location":"#ACOS-Goddard","page":"Main","title":"ACOS Goddard","text":"Welcome to ACOS Goddard, an independent implementation of the ACOS algorithm that was originally created at NASA JPL. The NASA JPL implementation of the algorithm is RtRetrievalFramework and is available here. Our implementation of ACOS uses the RetrievalToolbox library, which can be freely downloaded here. One can think of this as an own application that is built on top of RetrievalToolbox.\n\nThe purpose of this application is to serve as a demonstration for science users to see how a moderately complex CO_2 retrieval algorithm can be built and run with the RetrievalToolbox software library.\n\nBefore downloading or using this application, users are highly encouraged to read the important notes. Further, there are notable differences to the reference implementation as well as known issues, which are listed here.","category":"section"},{"location":"#Installation","page":"Main","title":"Installation","text":"","category":"section"},{"location":"#Installing-Julia-and-RetrievalToolbox","page":"Main","title":"Installing Julia and RetrievalToolbox","text":"We recommend installing Julia via JuliaUp. Instructions can be found here for various platforms. RetrievalToolbox can be directly installed via Julia's package manager, however the XRTM radiative transfer solver library must be installed manually. Instructions for both are found in the RetrievalToolbox repository.","category":"section"},{"location":"#Installing-packages-needed-for-ACOS-Goddard","page":"Main","title":"Installing packages needed for ACOS-Goddard","text":"The most convenient way to get started is to jump into the directory in which you have cloned ACOS-Goddard and install all required packages automatically. This is done by invoking Julia with the project argument:\n\n# (within the cloned directory)\njulia --project=./\n\nAnd from here, let Julia install all required packages:\n\nusing Pkg;\nPkg.add(path=\"https://www.github.com/US-GHG-Center/RetrievalToolbox.jl\");\nPkg.resolve();\nPkg.instantiate();\n\nThis should ideally install the needed modules to run the example provided here.","category":"section"},{"location":"#Obtaining-required-auxiliary-data","page":"Main","title":"Obtaining required auxiliary data","text":"In order to run the provided example(s), users must download additional data not present in this repository. First, a solar model is required. Our ACOS implementation currently supports two different solar model formats. One is the solar model file that is used in RtRetrievalFramework, which is the best choice for users who want to stick closer to the operational OCO code. That solar model can be downloaded from the Github repository with the following shell commands\n\ncd example_data\nwget https://github.com/nasa/RtRetrievalFramework/raw/refs/heads/master/input/common/input/l2_solar_model.h5\n\nAlternatively, users can make use of the TSIS-1 Hybrid Solar Reference Spectrum, developed and published by the Laboratory for Atmospheric and Space Physics (LASP) at the University of Colorado Boulder. The download portal is found here, or again use the following shell command to directly download the model file at 0.001 nm spectral resolution:\n\n# (assuming you are still in `example_data`)\nwget https://lasp.colorado.edu/lisird/resources/lasp/hsrs/v2/hybrid_reference_spectrum_p005nm_resolution_c2022-11-30_with_unc.nc\n\nNote that an appropriate change in the corresponding command line argument to the application must be done. The \"–solar_model\" command line argument must point to the right file. No further changes are needed, the application detects the type of model based on the file ending (.nc for the LASP TSIS file, and .h5 for the RtRetrievalFramework format). By default, examples use the model as provided by RtRetrievalFramework.\n\nFurther, the aerosol optical properties as well as some other additional data (such as the non-uniform sampling grid) are required:\n\n# (assuming you are still in `example_data`)\nwget https://github.com/nasa/RtRetrievalFramework/raw/refs/heads/master/input/common/input/l2_aerosol_combined.h5\nwget https://github.com/nasa/RtRetrievalFramework/raw/refs/heads/master/input/oco/input/l2_oco_static_input.h5\n\nNote that the location of these two files is hard-coded inside our application (./example_data/...), so if you want to replace these files or their location, you have to manually make the appropriate changes inside the *.jl files.","category":"section"},{"location":"#Obtaining-Spectroscopy","page":"Main","title":"Obtaining Spectroscopy","text":"As of now, RetrievalToolbox supports spectroscopy in the ABSCO formats only, recognizing the file format of the tables produced by NASA JPL, as well as those produced by the ReFRACtor/ABSCO toolset. To use this retrieval algorithm, users need to obtain the spectroscopy tables for O_2, CO_2 and H_2O. The GES-DISC hosts a webpage for the time being which lists contact addresses where researchers can request the files used in the operational OCO-2/3 data streams.","category":"section"},{"location":"#Running-Examples","page":"Main","title":"Running Examples","text":"Running the provided example retrieval is done as follows, assuming that XRTM_PATH is correctly set and the needed auxiliary files are downloaded and placed in the correct directories. It is important that the --project=./ argument is supplied, otherwise the Julia session has no knowledge of the additional packages needed by this application!\n\nXRTM_PROGRESS=1 julia --project=./ ./from_repl.jl\n\nor from within Julia, when started with --project=./\n\ninclude(\"from_repl.jl\")\n\nThe from_repl.jl script includes some reasonable default settings to run the provided example retrieval.\n\nNote that RetrievalToolbox supports multi-threading for the monochromatic RT calculations, and the number of threads that can be utilized is determined by the JULIA_NUM_THREADS environment variable. So to speed up the demo retrieval, use\n\nXRTM_PROGRESS=1 JULIA_NUM_THREADS=3 julia --project=./ ./from_repl.jl\n\nFor this particular set-up, choosing 3 threads tends to provide the best benefit, using more threads does not achieve notable speed-up in our experience. The high-accuracy approximation technique (LSI) cannot yet benefit from multi-threading. For parallel processing of multiple soundings via, e.g., GNU Parallel, users might want to benchmark which combination of parallel instances vs. the number of threads to use. The memory footprint also changes when using more than one thread.\n\nFor new users, we recommend starting with the interactive notebooks inside the examples folder. A working Jupyter installation is required, and it must be able to access the Julia kernel(s). In order to register Julia kernels with Jupyter (or JupyterLab), simply install IJulia by typing (MacOS/Linux) julia -e 'using Pkg; Pkg.add(\"IJulia\")' or manually inside the Julia REPL:\n\n] add IJulia\n\nOnce IJulia is installed through the package manager, a local notebook session can be spawned by typing\n\nnotebook()\n\nwhich will start the Jupyter server and open a web browser. Alternatively, users can also spawn Jupyter(Lab) from their preferred shell (jupyter, or juptyer-lab) and then navigate to the location of the example notebooks.","category":"section"},{"location":"#Command-line-arguments-for-the-run.jl-script","page":"Main","title":"Command line arguments for the run.jl script","text":"Instead of running from_repl.jl, users can of course tailor the inputs to the retrieval algorithm. Below is an example of how to call run.jl, which is the main application to be used. Like before, this assumes that the required auxiliary data is downloaded and placed into the correct folders, and that XRTM_PATH is correctly set. The below example runs a single retrieval with the sounding ID 2021030111564431. To process several soundings, users can invoke the --sounding_id_list command line argument, explained further below.\n\nXRTM_PROGRESS=1 JULIA_NUM_THREADS=3 julia --project=./ ./run.jl \\\n        --solar_model ./example_data/l2_solar_model.h5 \\\n        --L1b ./example_data/2021030111564431_inputs.h5 \\\n        --L2Met ./example_data/2021030111564431_inputs.h5 \\\n        --L2CPr ./example_data/2021030111564431_inputs.h5 \\\n        --output 2021030111564431.h5 \\\n        --o2_spec ./example_data/o2_v52.hdf \\\n        --o2_scale 1.0048 \\\n        --co2_spec ./example_data/co2_v52.hdf \\\n        --co2_scale_weak 0.994 \\\n        --co2_scale_strong 0.998 \\\n        --h2o_spec ./example_data/h2o_v52.hdf \\\n        --sounding_id 2021030111564431 \\ # alternative: --sounding_id_list sounding_id_list.txt\n        --spec 1,2,3 \\\n        --polarized true \\\n        --Lambertian false \\\n        --aerosols true \\\n        --retrieve_aerosols true \\\n        --LSI true \\\n        --Nhigh 16 \\\n        --dsigma_scale 2.0 \\\n        --gamma 50.0 \\\n        --max_iterations 10\n\nEach command line argument will be explained below.\n\n--solar_model: Points to the path of the solar model file, either the one that ships with RtRetrievalFramework, or the LASP TSIS-1 hybrid reference spectrum (see above on how to download them).\n--L1b: Points to the path of an OCO-2/3 L1b file (calibrated, geo-located measurements). Must be downloaded from the GES-DISC: OCO-2/3 L1B collection\n--L2Met: Points to the path of an OCO-2/3 L2Met file (meteorology and aerosols sampled at measurement locations). Must be downloaded from GES-DISC: OCO-2 L2Met collection or OCO-3 L2Met collection\n--L2CPr: Points to the path of an OCO-2/3 L2CPr file (CO2 prior profiles at measurement locations). Must be downloaded from the GES-DISC: OCO-2 L2CPr collection or OCO-3 L2CPr collection NOTE! The three files (L1b, L2Met and L2CPr) must belong to the same orbit to contain the data associated with one single sounding ID!\n--sounding_id: Must be a typical 16-digit OCO-type sounding ID, which identifies the single sounding to be processed.\n--sounding_id_list: Points to the path of a file that contains a list of 16-digit OCO-type sounding IDs. The file should be a text file with sounding IDs, one per line. When performing retrievals for many scenes, it can be advantageous to use this open instead of calling the algorithm for every scene individually, as one suffers the compilation step every time the algorithm is freshly called.\n--output: Path to the directory in which the output file will be written. NOTE! Within this application, any existing output file is automatically overwritten. If you need to skip existing files, it is best to implement those checks within the script(s) that execute the application. Alternatively, users can modify the code in main.jl. A single output file is created for each individual sounding ID; users who need a different solution (e.g. writing results into a big parallel NetCDF file) will need to write their own code.\n--touch_init: (optional) Determines whether the program will write an init-file to signify that this particular sounding ID has started processing. This is useful for book-keeping and to isolate soundings that make the program crash. Once the output file is successfully written out, the init-file is removed. The default is true.\n--o2_spec: Points to the path of the oxygen spectroscopy ABSCO file.\n--o2_scale: (optional) Must be a real number. The entire oxygen spectroscopy table is scaled by this value. For ABSCO version 5.2, the recommended value is 1.0048, but that number was derived with the RtRetrievalFramework and may not be the ideal choice for this algorithm. The default is 1.0.\n--co2_spec: Points to the path of the carbon dioxide spectroscopy ABSCO file.\n--co2_scale_weak: (optional). Must be a real number. The \"weak\" part of the CO2 spectroscopy table (< 2 µm) is is scaled by this number. For ABSCO version 5.2, the recommended value is 0.994, but that number was derived with the RtRetrievalFramework and may not be the ideal choice for this algorithm. The default is 1.0.\n--co2_scale_strong: (optional). Must be a real number. The \"strong\" part of the CO2 spectroscopy table (> 2 µm) is is scaled by this number. For ABSCO version 5.2, the recommended value is 0.998, but that number was derived with the RtRetrievalFramework and may not be the ideal choice for this algorithm. The default is 1.0.\n--h2o_spec: Points to the path of the water vapor spectroscopy ABSCO file.\n--spec: A comma-separated list of integers (1,2 and/or 3) that represent which spectrometers (1 = O_2 A-band, 2 = CO_2 band at 1.6 µm, 3 = CO_2 band at 2.06 µm) are used in the retrieval. This can be something like 1,3, 2 (for a single-band retrieval of CO_2), or to use all (standard) 1,2,3. The spectrometer also impacts the state vector - only those state vector elements will be used which make sense given the spectrometer configuration. For example, the CO_2 profile will only be retrieved if either spectrometer 2 or 3 are used. Surface pressure and SIF are not retrieved if spectrometer 1 is not in the list.\n--polarized: (optional) Must be true or false. If set to true, polarization is accounted for in the model, and the appropriate settings are chosen for the radiative transfer. The algorithm is faster if this is set to false, however note that accounting for polarization is required for accurate CO_2 retrievals from OCO-2/3 due to the polarization sensitivity of the instrument. The default is true.\n--Lambertian: (optional) Must be true or false. If set to true, a Lambertian BRDF is used as the surface model in the radiative transfer calculations. If set to false, the Rahman-Pinty-Verstraete (RPV) type BRDF is used, as laid out in the ACOS ATBD. The default is false.\n--aerosols: (optional) Must be true or false. If set to true, aerosols are part of the model atmosphere. The types and abundances are selected via the L2Met file. As in ACOS, the two most abundant tropospheric types are chosen, along with a high-altitude stratospheric sulphur type aerosol, a water cloud type and an ice cloud type. If set to false, none of these aerosols are considered in the algorithm at all, which results in significant speed-up of the run time (~5s per iteration). Aerosols are generally required for accurate retrievals. The default is true.\n--retrieve_aerosols: (optional) Must be true or false. If set to true, all aerosols that are in the atmosphere are being retrieved with all three shape parameters (total AOD, height and width of the aerosol layer). Setting this to false will still retain the aerosol layers in the model atmosphere, however none are being adjusted during the retrieval and will keep their first-guess value as informed by the L2Met (which samples the GEOS-IT model). The default is true.\n--LSI: (optional) Must be true or false. If set to true, the algorithm will use the Low Streams Interpolation technique to approximate high-accuracy multiple scattering RT calculations. If set to false, no high-accuracy RT computations are made and only the single-scattering and two-stream RT computations are performed. The default is true.\n--Nhigh: (optional) Must be an even integer >= 2. If LSI is set, Nhigh will the number of (full) quadrature streams used for the high-accuracy approximation. Larger numbers mean higher accuracy, but slower runtime. The default value is 16.\n--dsigma_scale: (optional) Must be a real number. This is the scale factor applied to the dsigma^2 calculation used to establish convergence of the retrieval (see OCO-2 ATBD Section 3.5.1). The default value is 2.0.\n--gamma: (optional) Must be a real number. This is the Levenberg-Marquardt gamma parameter that controls the step size of the inversion. The default value is 10.0, however we recommend higher values (e.g. 500) as our algorithm is known to behave more non-linearly when getting closer to the solution.\n--max_iterations: (optional) Must be an integer. The inversion is halted after --max_iterations number of iterations. Setting this to 1, for example, will cause the algorithm to execute the forward model once, update the state vector once, and then quit. Setting this to 0 will skip the forward model execution, but still return the objects that could be used for introspection of the retrieval scene setup when used interactively. The default value is 10.","category":"section"},{"location":"#Parallel-processing","page":"Main","title":"Parallel processing","text":"The application supports rudimentary parallel processing via Julia's built-in functions for distributed computing. From a user perspective, the only required change is to execute the script with multiple processes (or workers) with the -p flag, and ACOS Goddard will take care of the rest. In our example shipped in this repository, one would run 3 parallel processes in total to process all 3 IDs in the sounding_id_list.txt files at the same time. Note that the -p flag denotes the number of additional worker processes, so the total number of available processes is that number plus one.\n\nXRTM_PROGRESS=1 JULIA_NUM_THREADS=1 julia --project=./ -p 2 ./run.jl \\\n        --solar_model ./example_data/l2_solar_model.h5 \\\n        --L1b ./example_data/2021030111564431_inputs.h5 \\\n        --L2Met ./example_data/2021030111564431_inputs.h5 \\\n        --L2CPr ./example_data/2021030111564431_inputs.h5 \\\n        --output 2021030111564431.h5 \\\n        --touch_init true \\\n        --o2_spec ./example_data/o2_v52.hdf \\\n        --o2_scale 1.0048 \\\n        --co2_spec ./example_data/co2_v52.hdf \\\n        --co2_scale_weak 0.994 \\\n        --co2_scale_strong 0.998 \\\n        --h2o_spec ./example_data/h2o_v52.hdf \\\n        --sounding_id_list sounding_id_list.txt \\\n        --spec 1,2,3 \\\n        --polarized true \\\n        --Lambertian false \\\n        --aerosols true \\\n        --retrieve_aerosols true \\\n        --LSI true \\\n        --Nhigh 16 \\\n        --dsigma_scale 2.0 \\\n        --gamma 50.0 \\\n        --max_iterations 10\n\nNote that the ACOS Goddard application is not only spawned three times - we are making use of the SharedArray type for distributed computing in Julia such that the big spectroscopy tables are only loaded into memory once, and all worker processes access the same data. The -p flag determines the number of additional processes that are spawned; so -p 2 will spawn 2 more processes, and ACOS Goddard will perform retrievals on a total of 3 parallel processes. In multi-processing mode, logging outputs are filtered, so any logging message that does not start with [MAIN] is suppressed; users who want a different behavior should edit the corresponding code in main.jl, or change the corresponding logging message to start with [MAIN] if a particular log message is wanted in multi-processing mode.\n\nUsers are encouraged to try out various combinations of numbers of additional processes (-p) and numbers of threads (JULIA_NUM_THREADS) for optimal throughput, and results are likely to differ for different computing systems.\n\nEarly tests on a 32-core node with 64G memory indicate that it ~16 processes with 2 threads each will likely still run, whereas more processes or threads will hit the memory limit soon for a regular configuration. Work to optimize the multi-process batch processing is ongoing. Note that applications built with RetrievalToolbox are generally quite memory-hungry, most objects persist to allow users to introspect most aspects of the retrieval at any given time.\n\nFor a given list of sounding IDs, either ingested via the --sounding_id_list argument, or by providing more than one ID through --sounding_id, the application chops up the list into equal lengths (if possible) and lets each process run through its own sub-list. Note that this is a static assignment for now, and due to the simple nature of this solution, there is no re-balancing of the workload after the application is called. So if one worker happens to be given a list of sounding IDs which all have a bad quality flag, that worker process will simply do nothing until all other processes are finished with their respective batch of retrievals. Also note that Julia's SharedArray functionality only works on a single-node, so running this set-up on a cluster where workers are spawned on different nodes will not work.\n\nShould a worker process unexpectedly terminate, all references inside Julia's worker pool are removed automatically by Julia itself, so the program will keep running. However there is no re-balancing of the terminated worker's sounding ID list, so those soundings will not be processed in this run.\n\nnote: This is proof-of-concept as of now!\nThe current implementation of parallel processing is mainly a proof-of-concept and has not been tested for large-scale production. Users who need a more sophisticated multi-processing set-ups need to implement their own solution.","category":"section"},{"location":"important/#Important","page":"Important","title":"Important","text":"Things one must know when doing retrievals from OCO-2/3 measurements, which are not necessarily mentioned in the OCO L2 or L1 algorithm theoretical basis documents. Further, there are a few differences between the operational ACOS retrieval and the ACOS Goddard algorithm.","category":"section"},{"location":"important/#Spectral-EOFs","page":"Important","title":"Spectral EOFs","text":"Right now, the fitting of empirical orthogonal functions (EOFs) derived from spectral residuals, is not implemented. To our knowledge, this might have minor impact on convergence, but is not known to cause strong biases in the results otherwise. As a consequence, the spectral residuals are higher in magnitude, since for example the systematic errors associated with spectroscopy are still present in the modeled spectra. In general, the reduced chi^2 statistic will be higher with our implementation when compared to the published ACOS results.","category":"section"},{"location":"important/#Band-dependent-spectroscopy-scale-factors-and-their-tuning","page":"Important","title":"Band-dependent spectroscopy scale factors and their tuning","text":"The pre-calculated spectroscopy tables, known as ABSCO, can be found here. As noted in the documentation therein, the absorption cross section data may or may not be scaled by different factors, depending on the gas and the spectral band. The documentation also provides suggested scale factors for use in addition to the scale factors that are already applied to the data.\n\nUsers should be aware that those scale factors (the ones mentioned in the ABSCO documentation) were partially derived using retrievals using the NASA ACOS algorithm, and there is no expectation that these must also be the best choice for ACOS-Goddard. Differences in algorithm details and underlying calculations will likely necessitate different scaling factors to be used to achieve like-for-like results between reference ACOS and ACOS-Goddard.\n\nThe scale factors can be modified through command line arguments given to the main script (run.jl or run_mpi.jl) via --o2_scale 1.0, --co2_scale_weak 0.996 or --co2_scale_strong 1.001, for example, which will scale the oxygen spectroscopy data, and the CO_2 spectroscopy data for the weak (1.6 µm) and strong (2.06 µm) bands respectively.","category":"section"},{"location":"important/#ABSCO-scale-factor-tuning","page":"Important","title":"ABSCO scale factor tuning","text":"How should one proceed to derive factors?","category":"section"},{"location":"important/#Observation-azimuth-angle","page":"Important","title":"Observation azimuth angle","text":"The OCO-2/3 L1 files contain a field that describes the observation azimuth angle: /FootprintGeometry/footprint_azimuth (or the band-averaged /SoundingGeometry/sounding_solar_azimuth). The convention there is that both solar and observation azimuth angles are relative to an observer located at the ground footprint. This is not the same convention that most radiative transfer codes require (including XRTM). In fact, there is a 180 degree difference between the two conventions. Thus, the observation zenith angle is modified upon read-in by adding 180 degrees to the value stored in the L1 files. Therefore, if users compare the viewing_azimuth property of a SatelliteObserver object, they will note this discrepancy relative to the values from the L1 files.\n\nFurther, just before the viewing azimuth angle is fed into XRTM, another check is made to see if the relative angle, meaning the difference between viewing and solar azimuth angles, is within 0 and 360 degrees. The viewing azimuth angle is adjusted accordingly - however that is only a temporary calculation, this change is not reflected in the viewing_azimuth property. Thus, inspecting the /RetrievalGeometry/retrieval_azimuth of the output file could yield values larger than 360 degrees, and those numbers will also not necessarily be the same as those in comparable ACOS OCO-2/3 L2 files.\n\nThe following in-line documentation is found in RtRetrievalFramework/lib/Interface/level_1b.cc (but omitted in the L1 and L2 ATBDs):\n\nAzimuth is modified because the convention used by the OCO L1B file is to take both solar and observation angles as viewed from an observer standing in the FOV.  In this convention, the convention or glint would be a relative azimuth difference of 180 degrees, as the spacecraft and sun would be on opposite sides of the sky. However, the radiative transfer convention is that the azimuth angles must be the same for glint (it is \"follow the photons\" convention). However, we'd like the solar azimuth to not be changed, so as to continue to agree with zenaz, so this change of the observation azimuth has the effect of putting everything in a \"reverse follow-the-photons\" convention, where we look from the satellite to the FOV, then from the FOV to the sun.  Note that because of an old historical reason, however, both zenith angles remain > 0 and < 90, even in the RT convention.","category":"section"},{"location":"important/#L1B-bad-samples-are-removed-with-ACOS","page":"Important","title":"L1B bad samples are removed with ACOS","text":"L1B files contain fields /InstrumentHeader/bad_sample_list, which allows users to flag spectral samples that should be excluded from spectral fits in retrievals. Values that are non-zero are ignored in the reference ACOS algorithm by excluding them in the spectral fit. Those spectral samples do not appear at all in the various diagnostic files, such as the L2Dia family.\n\nIn ACOS-Goddard, we chose to include those spectral samples, however we inflate the associated noise-equivalent radiance to such a high amount that those spectral samples have no impact on the spectral fit. When comparing spectral fits between reference ACOS and ACOS-Goddard, users might see missing points that can be attributed to this difference in how bad samples are treated.","category":"section"},{"location":"important/#Scaled-Levenberg-Marquardt-iteration","page":"Important","title":"Scaled Levenberg-Marquardt iteration","text":"The OCO-2/3 L2 ATBD explains the used inverse formulation in the section Inverse Method, Formulation and Implementation. As mentioned there, we shall look at equation (5.36) in Rodgers (2000), which explicitly writes the state vector update at iteration i as (consult Rodgers (2000) and the OCO ATBDs for the meaning of the variables):\n\nmathbfx_i+1 = mathbfx_i + lbrack (1 + gamma) mathbfS_mathrma^-1 + mathbfK_i^mathrmT mathbfS_varepsilon^-1 mathbfK_i rbrack^-1 \ntimes lbrace mathbfK_i^mathrmT mathbfS_varepsilon^-1 lbrack mathbfy - mathbfF(mathbfx_i)rbrack - mathbfS_mathrma^-1 lbrack mathbfx_i - mathbfx_mathrmarbrack rbrace\n\nThe OCO-2/3 L2 ATBD then mentions that the state vector update is not calculated in that manner, but rather in the following way. First, we make a substitution and write the state vector update like so: mathrmdmathbfx_i = mathbfx_i+1 - mathbfx_i. Then we re-arrange the first in the brackets to obtain the following:\n\nlbrack (1 + gamma) mathbfS_mathrma^-1 + mathbfK_i^mathrmT mathbfS_varepsilon^-1 mathbfK_i rbrack mathrmdmathbfx_i = lbrace mathbfK_i^mathrmT mathbfS_varepsilon^-1 lbrack mathbfy - mathbfF(mathbfx_i)rbrack - mathbfS_mathrma^-1 lbrack mathbfx_i - mathbfx_mathrmarbrack rbrace\n\nThis is algebraically equivalent with the formulation above that is also found in Rodgers (2000), however the substantial difference is that the matrix inverse is no longer explicitly needed. As the OCO-2/3 L2 ATBD further elaborates, one can solve this problem with a variety of easily obtainable solvers, such as a least-squares solver. The left-hand side operator ((1 + gamma) mathbfS_mathrma^-1 + mathbfK_i^mathrmT mathbfS_varepsilon^-1 mathbfK_i) is a matrix-valued quantity, whereas the right-hand side (mathbfK_i^mathrmT mathbfS_varepsilon^-1 lbrack mathbfy - mathbfF(mathbfx_i)rbrack - mathbfS_mathrma^-1 lbrack mathbfx_i - mathbfx_mathrmarbrack) is a vector. Hence the problem reduces to a simple mathbfAcdotmathrmdmathbfx_i = mathbfb type problem.\n\nThe reference ACOS algorithm, however, actually applies a scaling to this equation, which is not mentioned in the ATBD. It is explained in lib/Implementation/connor_solver.cc, that both sides of the equation are first scaled by some matrix, which we will call mathbfN here.\n\nFirst, we can re-write the above equation to yield:\n\nmathbfN^mathrmT lbrack (1 + gamma) mathbfS_mathrma^-1 + mathbfK_i^mathrmT mathbfS_varepsilon^-1 mathbfK_i rbrack mathbfN mathbfN^-1 mathrmdmathbfx_i = mathbfN^mathrmT lbrace mathbfK_i^mathrmT mathbfS_varepsilon^-1 lbrack mathbfy - mathbfF(mathbfx_i)rbrack - mathbfS_mathrma^-1 lbrack mathbfx_i - mathbfx_mathrmarbrack rbrace\n\nNote that mathbfN mathbfN^-1 has been wedged in front of mathrmdmathbfx_i. In the above quoted reference ACOS code, mathbfN was chosen to be a diagonal matrix, consisting of the diagonal entries of the prior covariance matrix: mathbfN = mathrmdiag(mathbfS_mathrma).\n\nThe problem can now be formulated as\n\nmathbfA = mathbfN^mathrmT lbrack (1 + gamma) mathbfS_mathrma^-1 + mathbfK_i^mathrmT mathbfS_varepsilon^-1 mathbfK_i rbrack \nmathbfb = mathbfN^mathrmT lbrace mathbfK_i^mathrmT mathbfS_varepsilon^-1 lbrack mathbfy - mathbfF(mathbfx_i)rbrack - mathbfS_mathrma^-1 lbrack mathbfx_i - mathbfx_mathrmarbrack rbrace\n\nand we attempt to solve mathbfA cdot mathbfx = mathbfb.\n\nAgain, there is a difference between the OCO-2/3 ATBD and what is actually implemented in the reference ACOS. Rather than using some generic least-square solver to solve mathbfA cdot mathbfx = mathbfb, they solve the problem via singular value decomposition. Doing so, the left-hand side is decomposed:\n\nmathbfA = mathbfUmathbfSmathbfV^mathrmT\n\nwhere mathbfS is a diagonal matrix. In the case of reference ACOS, any diagonal entry s_m that is below some threshold 10^-12  is set to zero. With the modified entries to mathbfS, we can write the inverse as mathbfS^-1 = mathrmdiag(s_1 s_2 s_3 ldots 0) (where any s_m  10^-12 = 0) and the solution to the problem is\n\nmathbfx = mathbfV mathbfS^-1 mathbfU^mathrmTmathbfb\n\nand then finally\n\nmathrmdmathbfx_i = mathbfN mathbfx\n\nThus the new state vector becomes\n\nmathbfx_i+1 = mathbfx_i + mathrmdmathbfx_i\n\nACOS-Goddard implements this scheme via the function solve_LM_scaled that is provided within RetrievalToolbox.","category":"section"},{"location":"important/#Phase-function-expansion-coefficient-convention","page":"Important","title":"Phase function expansion coefficient convention","text":"The reference implementation, RtRetrievalFramework, uses the LIDORT family of radiative transfer solvers. Those models and codes use the so-called de Rooij convention for the phase function expansion coefficients. We make use of XRTM, which uses the Siewert convention.\n\nIn the de Rooij convention, the six needed expansion coefficients for the phase matrix are called alpha_1^l, alpha_2^l, alpha_3^l, alpha_4^l, beta_1^l and beta_2^l, whereas the Siewert convention calls them alpha_l, beta_l, zeta_l, delta_l, gamma_l and epsilon_l. Further, XRTM does not ingest the six moments as such, but requires -gamma_l and -epsilon_l.\n\nIn this application, and such is done also in the helper function that ships with RetrievalToolbox, we reorder the coefficients to match the Siewert convention, and also change the sign of both gamma_l and epsilon_l such that no further modification to the coefficients is needed. However, this also means that the MieMomAerosolProperty objects really store  alpha_l, beta_l, zeta_l, delta_l, -gamma_l and -epsilon_l.","category":"section"}]
}
